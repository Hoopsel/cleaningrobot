#include <ros/ros.h>
#include <geometry_msgs/Twist.h>

#include <wiringPi.h>

#define leftStepperDirectionPin 7
#define leftstepperStepPin 11
#define rightStepperDirectionPin 13
#define rightStepperStepPin 15

#define laserStepperDirectionPin 19
#define laserStepperStepPin 21

float rightStepperSpeed; // in m/s
float rightStepperRPM;
double rightStepperDelay = 10;
ros::Time rightStepperLastTime;



float leftStepperSpeed; // in m/s
float leftStepperRPM;
double leftStepperDelay = 10;
ros::Time leftStepperLastTime;

const float distanceBetweenTwoWheels = 0.313; // in m
const float wheelsRaduis = 0.04325; // in m


void rightTimerCallback(const ros::TimerEvent & event)
{
	if(digitalRead(rightStepperStepPin) == HIGH)
	{
		digitalWrite(rightStepperStepPin, LOW);

	} // end if

	else
	{
		digitalWrite(rightStepperStepPin, HIGH);

	} // end else

	ROS_INFO("Right timer\n");

} // end rightTimerCallback

void leftTimerCallback(const ros::TimerEvent & event)
{
	if(digitalRead(leftstepperStepPin) == HIGH)
	{
		digitalWrite(leftstepperStepPin, LOW);

	} // end if

	else
	{
		digitalWrite(leftstepperStepPin, HIGH);

	} // end else

	ROS_INFO("Left timer\n");

	

} // end leftTimerCallback

void cmd_velCallback (const geometry_msgs::Twist twist)
{

    rightStepperSpeed = (twist.angular.z * M_PI * distanceBetweenTwoWheels / 2) + twist.linear.x; // this is in m/s
    leftStepperSpeed =  (twist.linear.x * 2) - rightStepperSpeed;

    rightStepperRPM = rightStepperSpeed / (M_PI * wheelsRaduis);
    leftStepperRPM = leftStepperSpeed / (M_PI * wheelsRaduis);

    // calculate the delay for the rpm in msec
    rightStepperDelay = abs( 600 / (4 * rightStepperRPM) ) / 1000.0;
    leftStepperDelay =  abs( 600 / (4 * leftStepperRPM) ) / 1000.0;

    // Set the directions
    if(rightStepperSpeed < 0)
    {
      digitalWrite(rightStepperDirectionPin, LOW);

    } // end if

    else // rightStepperSpeed >= 0
    {
      digitalWrite(rightStepperDirectionPin, HIGH);

    } // end else

    if(leftStepperSpeed < 0)
    {
      digitalWrite(leftStepperDirectionPin, LOW);

    } // end if

    else // leftStepperSpeed >= 0
    {
      digitalWrite(leftStepperDirectionPin, HIGH);

    } // end else

	ROS_INFO("Right stepper delay: %f\n", rightStepperDelay);
	ROS_INFO("Left stepper delay: %f\n", leftStepperDelay);


    // Move the motors
	

} // end cmd_velCallback

int main(int argc, char **argv)
{
	ros::init(argc, argv, "motorsController");

	ros::NodeHandle nodeHandle;

	ros::Subscriber cmd_velSubscriber = nodeHandle.subscribe("cmd_vel", 10, cmd_velCallback);


	wiringPiSetupSys();
	system("gpio export 7 output");
	//pinMode(leftStepperDirectionPin, OUTPUT);

	system("gpio export 11 output");
	//pinMode(leftstepperStepPin, OUTPUT);

	system("gpio export 13 output");
	//pinMode(rightStepperDirectionPin, OUTPUT);

	system("gpio export 15 output");
	//pinMode(rightStepperStepPin, OUTPUT);

	system("gpio export 19 output");
	//pinMode(laserStepperDirectionPin, OUTPUT);

	system("gpio export 21 output");
	//pinMode(laserStepperStepPin, OUTPUT);
	
	// Set the laser stepper direction
	digitalWrite(laserStepperStepPin, HIGH);

	ros::Rate(1.0);
	while(nodeHandle.ok())
	{
		// keep moving the laser stepper
		digitalWrite(laserStepperStepPin, HIGH);
		sleep(0.001);
		digitalWrite(laserStepperStepPin, LOW);
		sleep(0.001);

		if(rightStepperDelay != 10)
		{
			ros::Timer rightStepperTimer = nodeHandle.createTimer(ros::Duration(0.1), rightTimerCallback, false);
			ros::Timer leftStepperTimer = nodeHandle.createTimer(ros::Duration(0.1), leftTimerCallback ,false);
	
		} // end if

		ros::spinOnce();

		
	} // end while


} // end main
